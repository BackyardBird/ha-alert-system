# packages/alert_system.yaml
# Version: 4.1.0 - FILE-BASED PERSISTENT THRESHOLD ALERTS
# Added file-based persistent storage for threshold alerts that survive restarts
# Improved binary automation YAML generator with proper indentation
# Uses shell commands to read/write to /config/threshold_alerts.txt

script:
  # ===================================
  # CORE ALERT SYSTEM SCRIPTS
  # ===================================
  
  send_alert:
    alias: "Send Alert"
    description: "Send a formatted alert via Telegram"
    fields:
      message:
        description: "Alert message content"
        example: "Kitchen smoke detector activated"
        required: true
      level:
        description: "Alert level (info/warning/critical)"
        example: "warning"
        default: "info"
      location:
        description: "Location/room where alert originated"
        example: "Kitchen"
        required: false
      include_timestamp:
        description: "Include timestamp in message"
        example: "true"
        default: true
      chat_id:
        description: "Specific chat ID to send to (optional)"
        example: "-1001234567890"
        required: false
      channel:
        description: "Alert channel (main/technical/both)"
        example: "main"
        default: "main"
    sequence:
      - variables:
          level_emoji: "{% if level == 'critical' %}üö®{% elif level == 'warning' %}‚ö†Ô∏è{% else %}‚ÑπÔ∏è{% endif %}"
          house_name: !secret house_name
          timestamp: "{% if include_timestamp | default(true) %}{{ now().strftime('%H:%M') }}{% endif %}"
          main_chat: !secret telegram_main_alerts
          tech_chat: !secret telegram_technical_alerts
      - choose:
          - conditions:
              - condition: template
                value_template: "{{ chat_id is defined and chat_id != '' }}"
            sequence:
              - action: telegram_bot.send_message
                data:
                  target: "{{ chat_id | int }}"
                  message: "<b>{{ level_emoji }} {{ house_name|upper }} {{ level|upper }}</b> {{ timestamp }}\n{{ message | e }}{% if location %}\nüìç {{ location | e }}{% endif %}"
                  parse_mode: "HTML"
          - conditions:
              - condition: template
                value_template: "{{ channel == 'main' }}"
            sequence:
              - action: telegram_bot.send_message
                data:
                  target: "{{ main_chat | int }}"
                  message: "<b>{{ level_emoji }} {{ house_name|upper }} {{ level|upper }}</b> {{ timestamp }}\n{{ message | e }}{% if location %}\nüìç {{ location | e }}{% endif %}"
                  parse_mode: "HTML"
          - conditions:
              - condition: template
                value_template: "{{ channel == 'technical' }}"
            sequence:
              - action: telegram_bot.send_message
                data:
                  target: "{{ tech_chat | int }}"
                  message: "<b>{{ level_emoji }} {{ house_name|upper }} {{ level|upper }}</b> {{ timestamp }}\n{{ message | e }}{% if location %}\nüìç {{ location | e }}{% endif %}"
                  parse_mode: "HTML"
          - conditions:
              - condition: template
                value_template: "{{ channel == 'both' }}"
            sequence:
              - action: telegram_bot.send_message
                data:
                  target: "{{ main_chat | int }}"
                  message: "<b>{{ level_emoji }} {{ house_name|upper }} {{ level|upper }}</b> {{ timestamp }}\n{{ message | e }}{% if location %}\nüìç {{ location | e }}{% endif %}"
                  parse_mode: "HTML"
              - action: telegram_bot.send_message
                data:
                  target: "{{ tech_chat | int }}"
                  message: "<b>{{ level_emoji }} {{ house_name|upper }} {{ level|upper }}</b> {{ timestamp }}\n{{ message | e }}{% if location %}\nüìç {{ location | e }}{% endif %}"
                  parse_mode: "HTML"
        default:
          - action: telegram_bot.send_message
            data:
              target: "{{ tech_chat | int }}"
              message: "<b>‚ö†Ô∏è {{ house_name|upper }} WARNING</b> {{ timestamp }}\nüö® ALERT SYSTEM: Invalid channel '{{ channel }}' specified. Message sent to technical channel as fallback.\n\nOriginal message: {{ message | e }}{% if location %}\nüìç {{ location | e }}{% endif %}"
              parse_mode: "HTML"

  quick_alert:
    alias: "Quick Alert"
    description: "Send a simple info-level alert to main channel"
    fields:
      message:
        description: "Alert message"
        required: true
      chat_id:
        description: "Specific chat ID (optional)"
        required: false
    sequence:
      - action: script.send_alert
        data:
          message: "{{ message }}"
          level: "info"
          channel: "main"
          chat_id: "{{ chat_id | default('') }}"
          include_timestamp: true

  system_alert:
    alias: "System Alert"
    description: "Send a system-level alert to technical channel"
    fields:
      message:
        description: "System alert message"
        required: true
      level:
        description: "Alert level"
        default: "warning"
      channel:
        description: "Alert channel (main/technical/both)"
        default: "technical"
      chat_id:
        description: "Specific chat ID (optional)"
        required: false
    sequence:
      - action: script.send_alert
        data:
          message: "üñ•Ô∏è SYSTEM: {{ message }}"
          level: "{{ level | default('warning') }}"
          channel: "{{ channel | default('technical') }}"
          chat_id: "{{ chat_id | default('') }}"
          location: ""
          include_timestamp: true

  security_alert:
    alias: "Security Alert"
    description: "Send a security alert to both channels"
    fields:
      message:
        description: "Security alert message"
        required: true
      location:
        description: "Location of security event"
        required: false
      chat_id:
        description: "Specific chat ID (optional)"
        required: false
    sequence:
      - action: script.send_alert
        data:
          message: "üîí SECURITY: {{ message }}"
          level: "critical"
          location: "{{ location | default('') }}"
          channel: "both"
          chat_id: "{{ chat_id | default('') }}"
          include_timestamp: true

  device_alert:
    alias: "Device Alert"
    description: "Send a device-related alert to technical channel"
    fields:
      device_name:
        description: "Name of the device"
        required: true
      message:
        description: "Device alert message"
        required: true
      level:
        description: "Alert level"
        default: "info"
      channel:
        description: "Alert channel (main/technical/both)"
        default: "technical"
      chat_id:
        description: "Specific chat ID (optional)"
        required: false
    sequence:
      - action: script.send_alert
        data:
          message: "{{ device_name }}: {{ message }}"
          level: "{{ level | default('info') }}"
          channel: "{{ channel | default('technical') }}"
          chat_id: "{{ chat_id | default('') }}"
          location: ""
          include_timestamp: true

  bulk_alert:
    alias: "Bulk Alert"
    description: "Send multiple alerts at once"
    fields:
      alerts:
        description: "List of alerts to send"
        required: true
    sequence:
      - repeat:
          for_each: "{{ alerts }}"
          sequence:
            - action: script.send_alert
              data:
                message: "{{ repeat.item.message }}"
                level: "{{ repeat.item.level | default('info') }}"
                location: "{{ repeat.item.location | default('') }}"
                channel: "{{ repeat.item.channel | default('main') }}"
                chat_id: "{{ repeat.item.chat_id | default('') }}"

  tech_alert:
    alias: "Technical Alert"
    description: "Send alert specifically to technical channel"
    fields:
      message:
        description: "Technical alert message"
        required: true
      level:
        description: "Alert level"
        default: "info"
      location:
        description: "Location (optional)"
        required: false
    sequence:
      - action: script.send_alert
        data:
          message: "{{ message }}"
          level: "{{ level | default('info') }}"
          location: "{{ location | default('') }}"
          channel: "technical"
          include_timestamp: true

  main_alert:
    alias: "Main Alert"
    description: "Send alert specifically to main channel"
    fields:
      message:
        description: "Main alert message"
        required: true
      level:
        description: "Alert level"
        default: "info"
      location:
        description: "Location (optional)"
        required: false
    sequence:
      - action: script.send_alert
        data:
          message: "{{ message }}"
          level: "{{ level | default('info') }}"
          location: "{{ location | default('') }}"
          channel: "main"
          include_timestamp: true

  test_alert:
    alias: "Test Alert System"
    description: "Send a test alert to verify the system is working"
    fields:
      chat_id:
        description: "Specific chat ID to test (optional)"
        required: false
      channel:
        description: "Channel to test (main/technical/both)"
        default: "both"
    sequence:
      - action: script.send_alert
        data:
          message: "Alert system test - everything is working correctly! üéâ"
          level: "info"
          channel: "{{ channel | default('both') }}"
          chat_id: "{{ chat_id | default('') }}"
          include_timestamp: true

  # ===================================
  # FILE-BASED PERSISTENT THRESHOLD ALERTS
  # ===================================

  load_threshold_alerts_from_file:
    alias: "Load Threshold Alerts from File"
    description: "Load threshold alerts from persistent file storage"
    sequence:
      # Create file if it doesn't exist, then read it
      - action: shell_command.ensure_threshold_file
      - delay:
          milliseconds: 500
      # Read file content into a sensor (we'll create a command_line sensor)
      - action: homeassistant.update_entity
        target:
          entity_id: sensor.threshold_alerts_file_content
      - delay:
          milliseconds: 500
      # Distribute the loaded content to display helpers
      - action: script.distribute_file_alerts_to_helpers

  save_threshold_alerts_to_file:
    alias: "Save Threshold Alerts to File"
    description: "Save current alerts to persistent file storage"
    sequence:
      - variables:
          # Combine all current alerts from helpers
          all_alerts: "{{ states('input_text.threshold_entities') }}{% if states('input_text.threshold_entities_2') %}|{{ states('input_text.threshold_entities_2') }}{% endif %}{% if states('input_text.threshold_entities_3') %}|{{ states('input_text.threshold_entities_3') }}{% endif %}"
          # Clean up empty entries
          clean_alerts: "{{ all_alerts.split('|') | reject('eq', '') | list | join('|') }}"
      - action: shell_command.save_threshold_alerts
        data:
          alerts: "{{ clean_alerts }}"
      - delay:
          milliseconds: 500
      # Update the sensor to reflect the new file content
      - action: homeassistant.update_entity
        target:
          entity_id: sensor.threshold_alerts_file_content

  distribute_file_alerts_to_helpers:
    alias: "Distribute File Alerts to Helpers"
    description: "Distribute alerts from file to UI helpers"
    sequence:
      - variables:
          file_content: "{{ states('sensor.threshold_alerts_file_content') }}"
          alert_list: "{{ file_content.split('|') if file_content not in ['unknown', 'unavailable', ''] else [] }}"
          chunk1: "{{ alert_list[0:8] | join('|') }}"
          chunk2: "{{ alert_list[8:16] | join('|') }}"
          chunk3: "{{ alert_list[16:24] | join('|') }}"
      - action: input_text.set_value
        target:
          entity_id: input_text.threshold_entities
        data:
          value: "{{ chunk1 }}"
      - action: input_text.set_value
        target:
          entity_id: input_text.threshold_entities_2
        data:
          value: "{{ chunk2 }}"
      - action: input_text.set_value
        target:
          entity_id: input_text.threshold_entities_3
        data:
          value: "{{ chunk3 }}"

  add_persistent_threshold_alert:
    alias: "Add Persistent Threshold Alert"
    description: "Add alert with file-based persistence"
    fields:
      entity_id:
        description: "Entity to monitor"
        required: true
        example: "sensor.temperature"
      threshold:
        description: "Threshold value"
        required: true
        example: "25"
      condition:
        description: "Trigger condition"
        required: true
        example: "above"
      custom_message:
        description: "Custom alert message (optional)"
        required: false
        example: "Temperature is critical"
    sequence:
      - variables:
          entity_name: "{{ state_attr(entity_id, 'friendly_name') or entity_id.split('.')[1] | replace('_', ' ') | title }}"
          default_message: "{% if condition == 'above' %}{{ entity_name }} is above threshold{% else %}{{ entity_name }} is below threshold{% endif %}"
          alert_message: "{{ custom_message if custom_message else default_message }}"
          new_entry: "{{ entity_id }}:{{ threshold }}:{{ condition }}:{{ alert_message }}"
      # Load current alerts from file
      - action: script.load_threshold_alerts_from_file
      - delay:
          seconds: 1
      # Add to the first helper that has space
      - choose:
          - conditions:
              - condition: template
                value_template: "{{ (states('input_text.threshold_entities') | length + new_entry | length + 1) <= 250 }}"
            sequence:
              - action: input_text.set_value
                target:
                  entity_id: input_text.threshold_entities
                data:
                  value: "{% if states('input_text.threshold_entities') %}{{ states('input_text.threshold_entities') }}|{{ new_entry }}{% else %}{{ new_entry }}{% endif %}"
          - conditions:
              - condition: template
                value_template: "{{ (states('input_text.threshold_entities_2') | length + new_entry | length + 1) <= 250 }}"
            sequence:
              - action: input_text.set_value
                target:
                  entity_id: input_text.threshold_entities_2
                data:
                  value: "{% if states('input_text.threshold_entities_2') %}{{ states('input_text.threshold_entities_2') }}|{{ new_entry }}{% else %}{{ new_entry }}{% endif %}"
          - conditions:
              - condition: template
                value_template: "{{ (states('input_text.threshold_entities_3') | length + new_entry | length + 1) <= 250 }}"
            sequence:
              - action: input_text.set_value
                target:
                  entity_id: input_text.threshold_entities_3
                data:
                  value: "{% if states('input_text.threshold_entities_3') %}{{ states('input_text.threshold_entities_3') }}|{{ new_entry }}{% else %}{{ new_entry }}{% endif %}"
        default:
          - action: script.tech_alert
            data:
              message: "Error: All threshold storage helpers are full. Maximum 24 alerts supported."
              level: warning
      # Save back to file
      - action: script.save_threshold_alerts_to_file
      - action: script.tech_alert
        data:
          message: "Added persistent threshold alert for {{ entity_name }}: {{ condition }} {{ threshold }}"
          level: info

  remove_persistent_threshold_alert:
    alias: "Remove Persistent Threshold Alert"
    description: "Remove alert from file-based persistent storage"
    fields:
      entity_id:
        description: "Entity to remove"
        required: true
    sequence:
      # Load current alerts from file
      - action: script.load_threshold_alerts_from_file
      - delay:
          seconds: 1
      # Remove from each helper
      - if:
          - condition: template
            value_template: "{{ entity_id + ':' in states('input_text.threshold_entities') }}"
        then:
          - variables:
              entries: "{{ states('input_text.threshold_entities').split('|') }}"
              filtered_entries: "{{ entries | reject('match', '^' + entity_id + ':.*') | list }}"
              new_content: "{{ filtered_entries | join('|') }}"
          - action: input_text.set_value
            target:
              entity_id: input_text.threshold_entities
            data:
              value: "{{ new_content }}"
      - if:
          - condition: template
            value_template: "{{ entity_id + ':' in states('input_text.threshold_entities_2') }}"
        then:
          - variables:
              entries: "{{ states('input_text.threshold_entities_2').split('|') }}"
              filtered_entries: "{{ entries | reject('match', '^' + entity_id + ':.*') | list }}"
              new_content: "{{ filtered_entries | join('|') }}"
          - action: input_text.set_value
            target:
              entity_id: input_text.threshold_entities_2
            data:
              value: "{{ new_content }}"
      - if:
          - condition: template
            value_template: "{{ entity_id + ':' in states('input_text.threshold_entities_3') }}"
        then:
          - variables:
              entries: "{{ states('input_text.threshold_entities_3').split('|') }}"
              filtered_entries: "{{ entries | reject('match', '^' + entity_id + ':.*') | list }}"
              new_content: "{{ filtered_entries | join('|') }}"
          - action: input_text.set_value
            target:
              entity_id: input_text.threshold_entities_3
            data:
              value: "{{ new_content }}"
      # Save back to file
      - action: script.save_threshold_alerts_to_file
      - action: script.tech_alert
        data:
          message: "Removed persistent threshold alert for {{ entity_id }}"
          level: info

  create_threshold_alert_from_form:
    alias: "Create Threshold Alert from Form"
    description: "Create persistent threshold alert using the card form inputs"
    sequence:
      - variables:
          entity_id: "{{ states('input_text.temp_threshold_entity') }}"
          threshold: "{{ states('input_text.temp_threshold_value') }}"
          condition: "{{ states('input_select.temp_threshold_condition') }}"
          message: "{{ states('input_text.temp_threshold_message') }}"
      - choose:
          - conditions:
              - condition: template
                value_template: "{{ entity_id == '' or entity_id == 'unavailable' or entity_id == 'unknown' }}"
            sequence:
              - action: script.tech_alert
                data:
                  message: "Error: Please enter an entity ID"
                  level: warning
          - conditions:
              - condition: template
                value_template: "{{ '.' not in entity_id }}"
            sequence:
              - action: script.tech_alert
                data:
                  message: "Error: Entity ID must contain a dot (like sensor.temperature)"
                  level: warning
          - conditions:
              - condition: template
                value_template: "{{ states(entity_id) in ['unknown', 'unavailable'] }}"
            sequence:
              - action: script.tech_alert
                data:
                  message: "Error: Entity '{{ entity_id }}' not found. Please check the entity ID."
                  level: warning
        default:
          - action: script.add_persistent_threshold_alert
            data:
              entity_id: "{{ entity_id }}"
              threshold: "{{ threshold }}"
              condition: "{{ condition }}"
              custom_message: "{{ message if message != '' else '' }}"
          # Clear the form after successful creation
          - action: input_text.set_value
            target:
              entity_id: input_text.temp_threshold_entity
            data:
              value: ""
          - action: input_text.set_value
            target:
              entity_id: input_text.temp_threshold_message
            data:
              value: ""
          - action: input_text.set_value
            target:
              entity_id: input_text.temp_threshold_value
            data:
              value: "20"

  remove_threshold_alert_from_form:
    alias: "Remove Threshold Alert from Form"
    description: "Remove persistent threshold alert using the card form"
    sequence:
      - variables:
          entity_id: "{{ states('input_text.temp_remove_entity') }}"
      - if:
          - condition: template
            value_template: "{{ entity_id != '' and entity_id != 'unknown' and entity_id != 'unavailable' }}"
        then:
          - action: script.remove_persistent_threshold_alert
            data:
              entity_id: "{{ entity_id }}"
          - action: input_text.set_value
            target:
              entity_id: input_text.temp_remove_entity
            data:
              value: ""
        else:
          - action: script.tech_alert
            data:
              message: "Error: Please enter a valid entity ID to remove"
              level: warning

  list_threshold_alerts:
    alias: "List Persistent Threshold Alerts"
    description: "Show all configured persistent threshold alerts"
    sequence:
      - action: homeassistant.update_entity
        target:
          entity_id: sensor.threshold_alerts_file_content
      - delay:
          milliseconds: 500
      - action: script.tech_alert
        data:
          message: |
            üìä PERSISTENT THRESHOLD ALERTS STATUS
            
            File Content: {{ states('sensor.threshold_alerts_file_content') or 'Empty' }}
            Total Alerts: {{ states('sensor.threshold_alerts_file_content').split('|') | length if states('sensor.threshold_alerts_file_content') not in ['unknown', 'unavailable', ''] else 0 }}
            
            Format: entity_id:threshold:condition:message
          level: info

  clear_all_threshold_alerts:
    alias: "Clear All Persistent Threshold Alerts"
    description: "Remove all configured persistent threshold alerts"
    sequence:
      - action: input_text.set_value
        target:
          entity_id: input_text.threshold_entities
        data:
          value: ""
      - action: input_text.set_value
        target:
          entity_id: input_text.threshold_entities_2
        data:
          value: ""
      - action: input_text.set_value
        target:
          entity_id: input_text.threshold_entities_3
        data:
          value: ""
      - action: shell_command.clear_threshold_alerts
      - delay:
          milliseconds: 500
      - action: homeassistant.update_entity
        target:
          entity_id: sensor.threshold_alerts_file_content
      - action: script.tech_alert
        data:
          message: "All persistent threshold alerts have been cleared"
          level: warning

  test_threshold_alert:
    alias: "Test Threshold Alert"
    description: "Send a test threshold alert"
    sequence:
      - action: script.send_alert
        data:
          message: |
            üß™ THRESHOLD ALERT TEST
            
            This is a test of the threshold alert system.
            Current time: {{ now().strftime('%H:%M:%S') }}
          level: info
          channel: "{{ states('input_select.threshold_alert_channel') }}"
          location: "Test System"

  # ===================================
  # BINARY SENSOR AUTOMATION GENERATOR
  # ===================================

  generate_binary_automation_yaml:
    alias: "Generate Binary Automation YAML"
    description: "Generate automation YAML with proper formatting"
    sequence:
      - variables:
          entity: "{{ states('input_text.binary_automation_entity') }}"
          message: "{{ states('input_text.binary_automation_message') }}"
          location: "{{ states('input_text.binary_automation_location') }}"
          trigger_state_raw: "{{ states('input_select.binary_automation_trigger_state') }}"
          trigger_state: "{% if trigger_state_raw == 'Device Offline' %}unavailable{% else %}{{ trigger_state_raw }}{% endif %}"
          level: "{{ states('input_select.binary_automation_level') }}"
          channel: "{{ states('input_select.binary_automation_channel') }}"
      - choose:
          - conditions:
              - condition: template
                value_template: "{{ entity == '' or entity == 'unknown' or entity == 'unavailable' }}"
            sequence:
              - action: persistent_notification.create
                data:
                  title: "‚ùå Missing Entity ID"
                  message: "Please enter a binary sensor entity ID."
                  notification_id: "yaml_error"
          - conditions:
              - condition: template
                value_template: "{{ message == '' or message == 'unknown' or message == 'unavailable' }}"
            sequence:
              - action: persistent_notification.create
                data:
                  title: "‚ùå Missing Alert Message"
                  message: "Please enter an alert message."
                  notification_id: "yaml_error"
          - conditions:
              - condition: template
                value_template: "{{ states(entity) in ['unknown', 'unavailable'] }}"
            sequence:
              - action: persistent_notification.create
                data:
                  title: "‚ùå Entity Not Found"
                  message: "Entity '{{ entity }}' not found or unavailable."
                  notification_id: "yaml_error"
        default:
          - variables:
              entity_name: "{{ state_attr(entity, 'friendly_name') or entity.split('.')[1] | replace('_', ' ') | title }}"
              automation_name: "{{ entity_name }} Alert"
          - action: input_text.set_value
            target:
              entity_id: input_text.generated_automation_yaml
            data:
              value: "alias: \"{{ automation_name }}\"\ndescription: \"Alert when {{ entity_name }} ‚Üí {{ trigger_state }}\"\ntrigger:\n- platform: state\n  entity_id: {{ entity }}\n  to: \"{{ trigger_state }}\"\ncondition: []\naction:\n- action: script.send_alert\n  data:"
          - action: input_text.set_value
            target:
              entity_id: input_text.generated_automation_yaml_2
            data:
              value: "    message: \"{{ message }}\"\n    level: \"{{ level }}\"\n    channel: \"{{ channel }}\"{% if location != '' %}\n    location: \"{{ location }}\"{% endif %}"
          - action: input_text.set_value
            target:
              entity_id: input_text.generated_automation_yaml_3
            data:
              value: "mode: single"
          - action: persistent_notification.create
            data:
              title: "‚úÖ Automation YAML Generated"
              message: "Generated automation for {{ entity_name }}."
              notification_id: "yaml_generated"

  clear_binary_automation_form:
    alias: "Clear Binary Automation Form"
    description: "Reset all form fields"
    sequence:
      - action: input_text.set_value
        target:
          entity_id: input_text.binary_automation_entity
        data:
          value: ""
      - action: input_text.set_value
        target:
          entity_id: input_text.binary_automation_message
        data:
          value: ""
      - action: input_text.set_value
        target:
          entity_id: input_text.binary_automation_location
        data:
          value: ""
      - action: input_text.set_value
        target:
          entity_id: input_text.generated_automation_yaml
        data:
          value: ""
      - action: input_text.set_value
        target:
          entity_id: input_text.generated_automation_yaml_2
        data:
          value: ""
      - action: input_text.set_value
        target:
          entity_id: input_text.generated_automation_yaml_3
        data:
          value: ""
      - action: input_select.select_option
        target:
          entity_id: input_select.binary_automation_trigger_state
        data:
          option: "on"
      - action: input_select.select_option
        target:
          entity_id: input_select.binary_automation_level
        data:
          option: "warning"
      - action: input_select.select_option
        target:
          entity_id: input_select.binary_automation_channel
        data:
          option: "main"

# ===================================
# SHELL COMMANDS FOR FILE OPERATIONS
# ===================================

shell_command:
  ensure_threshold_file: 'touch /config/threshold_alerts.txt'
  save_threshold_alerts: 'echo "{{ alerts }}" > /config/threshold_alerts.txt'
  clear_threshold_alerts: 'echo "" > /config/threshold_alerts.txt'

# ===================================
# COMMAND LINE SENSOR FOR FILE READING
# ===================================

sensor:
  - platform: command_line
    name: threshold_alerts_file_content
    command: 'cat /config/threshold_alerts.txt 2>/dev/null || echo ""'
    scan_interval: 60

# ===================================
# INPUT HELPERS
# ===================================

input_text:
  # Display helpers (for UI compatibility) - correct 255 max
  threshold_entities:
    name: "Threshold Alert Entities"
    initial: ""
    max: 255

  threshold_entities_2:
    name: "Threshold Alert Entities (Group 2)"
    initial: ""
    max: 255

  threshold_entities_3:
    name: "Threshold Alert Entities (Group 3)" 
    initial: ""
    max: 255

  # Form helpers
  temp_threshold_entity:
    name: "Temporary Threshold Entity"
    initial: ""
    max: 100

  temp_threshold_value:
    name: "Temporary Threshold Value"
    initial: "20"
    max: 20

  temp_threshold_message:
    name: "Temporary Threshold Message"
    initial: ""
    max: 200

  temp_remove_entity:
    name: "Temporary Remove Entity"
    initial: ""
    max: 100

  # Binary automation form helpers
  binary_automation_entity:
    name: "Binary Automation Entity"
    initial: ""
    max: 100

  binary_automation_message:
    name: "Binary Automation Message"
    initial: ""
    max: 200

  binary_automation_location:
    name: "Binary Automation Location"
    initial: ""
    max: 100

  # Generated YAML storage
  generated_automation_yaml:
    name: "Generated Automation YAML"
    initial: ""
    max: 255

  generated_automation_yaml_2:
    name: "Generated Automation YAML (Part 2)"
    initial: ""
    max: 255

  generated_automation_yaml_3:
    name: "Generated Automation YAML (Part 3)"
    initial: ""
    max: 255

input_boolean:
  threshold_alerts_enabled:
    name: "Enable Threshold Alerts"
    initial: true
    icon: mdi:alert-circle

input_select:
  threshold_alert_channel:
    name: "Default Alert Channel"
    options:
      - main
      - technical
      - both
    initial: main
    icon: mdi:message-alert

  temp_threshold_condition:
    name: "Temporary Threshold Condition"
    options:
      - "above"
      - "below"
    initial: "above"

  binary_automation_level:
    name: "Binary Automation Alert Level"
    options:
      - info
      - warning
      - critical
    initial: warning
    icon: mdi:alert

  binary_automation_channel:
    name: "Binary Automation Alert Channel"
    options:
      - main
      - technical
      - both
    initial: main
    icon: mdi:message-alert

  binary_automation_trigger_state:
    name: "Binary Automation Trigger State"
    options:
      - "on"
      - "off"  
      - "Device Offline"
    initial: "on"
    icon: mdi:state-machine

# ===================================
# TEMPLATE SENSORS
# ===================================

template:
  - sensor:
      - name: "Threshold Alert Count"
        unique_id: "pkg_threshold_alert_count"
        state: "{% set file_content = states('sensor.threshold_alerts_file_content') %}{{ file_content.split('|') | length if file_content not in ['unknown', 'unavailable', ''] else 0 }}"
        icon: mdi:counter
        
      - name: "Threshold Alert Status"
        unique_id: "pkg_threshold_alert_status"
        state: "{% if is_state('input_boolean.threshold_alerts_enabled', 'on') %}{% set count = states('sensor.threshold_alert_count') | int %}{% if count > 0 %}Monitoring {{ count }} entities (File-based){% else %}No entities configured{% endif %}{% else %}Disabled{% endif %}"
        icon: mdi:shield-check

      - name: "Binary Automation Form Status"
        unique_id: "pkg_binary_automation_form_status"
        state: "{% set entity = states('input_text.binary_automation_entity') %}{% set message = states('input_text.binary_automation_message') %}{% if entity != '' and entity != 'unknown' and message != '' and message != 'unknown' %}{% if states(entity) not in ['unknown', 'unavailable'] %}Ready to generate{% else %}Invalid entity{% endif %}{% else %}Fill required fields{% endif %}"
        icon: mdi:form-select

# ===================================
# AUTOMATIONS 
# ===================================

automation:
  - alias: "Threshold Alert Monitor"
    id: "threshold_alert_monitor"
    description: "Monitor entities for threshold breaches using file-based persistence"
    trigger:
      - platform: state
        entity_id: sensor.*
    condition:
      - condition: state
        entity_id: input_boolean.threshold_alerts_enabled
        state: 'on'
      # Check if this entity is in any of the display helpers
      - condition: or
        conditions:
          - condition: template
            value_template: "{{ trigger.entity_id + ':' in states('input_text.threshold_entities') }}"
          - condition: template
            value_template: "{{ trigger.entity_id + ':' in states('input_text.threshold_entities_2') }}"
          - condition: template
            value_template: "{{ trigger.entity_id + ':' in states('input_text.threshold_entities_3') }}"
    action:
      - variables:
          triggered_entity: "{{ trigger.entity_id }}"
          new_state: "{{ trigger.to_state.state }}"
          old_state: "{{ trigger.from_state.state if trigger.from_state else 'unknown' }}"
          # Combine all display helpers content
          all_content: "{{ states('input_text.threshold_entities') }}|{{ states('input_text.threshold_entities_2') }}|{{ states('input_text.threshold_entities_3') }}"
      # Process all entries to find matching entity
      - repeat:
          for_each: "{{ all_content.split('|') }}"
          sequence:
            - if:
                - condition: template
                  value_template: "{{ repeat.item != '' and repeat.item.startswith(triggered_entity + ':') }}"
              then:
                - variables:
                    parts: "{{ repeat.item.split(':') }}"
                    threshold_value: "{{ parts[1] | float }}"
                    condition_type: "{{ parts[2] }}"
                    alert_message: "{{ parts[3] if parts | length > 3 else 'Threshold alert' }}"
                    current_val: "{{ new_state | float(0) }}"
                    old_val: "{{ old_state | float(0) }}"
                    threshold_crossed: "{% if condition_type == 'above' %}{{ current_val > threshold_value and old_val <= threshold_value }}{% else %}{{ current_val < threshold_value and old_val >= threshold_value }}{% endif %}"
                - if:
                    - condition: template
                      value_template: "{{ threshold_crossed }}"
                  then:
                    - action: script.send_alert
                      data:
                        message: "üö® {{ alert_message }} - Current: {{ new_state }}{{ state_attr(triggered_entity, 'unit_of_measurement') or '' }} - Threshold: {{ condition_type }} {{ threshold_value }}{{ state_attr(triggered_entity, 'unit_of_measurement') or '' }}"
                        level: warning
                        channel: "{{ states('input_select.threshold_alert_channel') }}"
                        location: "{{ state_attr(triggered_entity, 'friendly_name') or triggered_entity.split('.')[1] | replace('_', ' ') | title }}"

  - alias: "Load Threshold Alerts on Startup"
    id: "load_threshold_alerts_startup" 
    description: "Load file-based alerts to display helpers on startup"
    trigger:
      - platform: homeassistant
        event: start
    action:
      - delay:
          seconds: 30  # Wait for system to fully start
      - action: script.load_threshold_alerts_from_file
      - delay:
          seconds: 2
      - action: script.tech_alert
        data:
          message: "Threshold alert system loaded {{ states('sensor.threshold_alert_count') }} file-based persistent alerts"
          level: info